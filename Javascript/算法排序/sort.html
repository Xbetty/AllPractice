<!DOCTYPE html>
<html>
<head>
	<title>排序</title>
</head>
<body>
<script type="text/javascript">
	/*
	一.基本排序算法
	基本排序算法的核心思想就是对一组数据按照一定的顺序重新排序，其中重排时一般都会用到一组嵌套的for循环，外循环会遍历数组的每一项元素，内循环则用于进行元素直接的比较。
	*/
	// 1.冒泡排序
	/*
	冒泡排序时比较经典的算法之一，也是排序最慢的算法之一，因为它的实现是非常的容易的。
	冒泡排序的算法思想：
	1.比较相邻的元素，如果第一个比第二个大，就交换它们两个；
	2.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样最终最大数被交换到最后的位置；
	3.除了最后一个元素以外，针对所有的元素重复以上的步骤；
	4.重复步骤1~3，知道排序完成。
	*/
	// 倒序
	function bubbleSortDesc (data) {
		var temp = 0;
		console.log('data', data)
		for (var i = data.length; i > 0; i--) {
			console.log('data1111111111111', data)
			for (var j = 0; j < i - 1; j++) {
				if (data[j] > data[j+1]) {
					temp = data[j]
					data[j] = data[j+1]
					data[j+1] = temp
				}
			}
		}
		return data;
	}
	console.log('冒泡排序倒序bubbleSort', bubbleSortDesc([3,2,1,5,4]))




	// 升序
	function bubbleSortAsc (data) {
		var temp = 0;
		for (var i = 0; i < data.length; i++) {
			console.log('data222222222222', data)
			for (var j = 0; j <= i; j++) {
				if (data[j] > data[j+1]) {
					temp = data[j]
					data[j] = data[j+1]
					data[j+1] = temp
				}
			}
		}
		return data;
	}
	console.log('冒泡排序升序bubbleSort', bubbleSortAsc([3,2,1,5,4]))



	// 2.选择排序
	/*
	选择排序是一种比较简单直观的排序算法。
	算法思想：从数组的开头开始遍历，将第一个元素和其他元素分别进行比较，记录最小的元素，等循环结束之后，将最小的元素放到数组的第一个位置上，
	然后从数组的第二个位置开始继续执行上述步骤。当进行到数组倒数第二个位置的时候，所有的数据就完成了排序。

	选择排序同样会用到嵌套循环，外循环从数组第一个位置移到倒数第二个位置；内循环从第二个位置移动到数组最后一个位置，查找比当前外循环所指向的元素还要小的元素，
	*/
	function selectionSort (data) {
		for (var i = 0; i < data.length; i++) {
			console.log('data', data)
			var min = data[i]
			var temp
			var index = i
			for (var j = i+1; j < data.length; j++) {
				if (data[j] < min) {
					min = data[j]
					index = j
				}
			}
			temp = data[i]
			data[i] = min
			data[index] = temp
		}
		return data
	}
	console.log('选择排序selectionSort', selectionSort([1,5,3,4,2]))


	// 3.插入排序
	/*
	插入排序有点类似人类按字母顺序对数据及逆行排序，就如同你打扑克牌一样，将摸来的扑克按大小放在合适的位置一样。它的原理就是通过嵌套循环，外循环将数组挨个移动，而内循环则对外循环中选中的元素及它后面的元素进行比较；如果外循环中选中的元素比内循环中选中的要小，那么数组元素是会向右移动，为内循环中的这个元素腾出位置。

	实现步骤：
	1.从第一个元素开始，该元素是默认已经被排序
	2.取出下一个元素，在已经排序的元素序列中从后向前扫描
	3.如果该元素（已排序）大于新元素，将该元素移动到下一位置
	4.重复步骤3，直到找到已排序的元素小于或者等于新元素的位置
	5.将新元素插入到该位置
	6.重复步骤2~5，知道排序完成
	*/
	// while循环
	// function insertionSort (data) {
	// 	var len = data.length;
	// 	for (var i = 1; i < len; i++) {
	// 		console.log('data', data)
	// 		var key = data[i]
	// 		var j = i - 1
	// 		while (j >= 0 && data[j] > key) {
	// 			data [j + 1] = data[j]
	// 			j--
	// 			// console.log('data1111111111', data)
	// 		}
	// 		data[j+1] = key
	// 		// console.log('data22222222222222', data)
	// 	}
	// 	return data
	// }
	// console.log('插入排序while：insertionSort', insertionSort([2,1,3,5,4]))

	// for循环
	function insertionSort (data) {
		var len = data.length;
		for (var i = 1; i < len; i++) {
			console.log('data', data)
			var key = data[i]
			for (var j = i-1; j >= 0; j--) {
				if(data[j] > key) {
					data[j+1] = data [j]
					data[j] = key
				}
				// console.log('data1111111', data)
			}
		}
		return data
	}
	console.log('插入排序for：insertionSort', insertionSort([2,1,3,5,4,0]))

	// 三种排序算法的效率
	console.log('冒泡排序：')
	console.time('bubbleSort')
	console.timeEnd('bubbleSort')
	console.log('选择排序')
	console.time('selectionSort')
	console.timeEnd('selectionSort')
	console.log('插入排序')
	console.time('insertionSort')
	console.timeEnd('insertionSort')

	// 高级排序算法
	// 快速排序
	/*
	快速排序是处理大数据最快的排序算法之一，它也是一种分而治之的算法，通过递归方式将数据一次分解为包含较小元素和较大元素的不同子序列，会不断重复这个步骤，直到所有的序列全部为有序的，最后将这些子序列一次拼接起来，就可得到排序好的数据。

	该算法首先要从数列中选出一个元素作为基数（pivot）。接着所有的数据都将围绕着这个基数进行，将小于该基数的元素放在它的左边，大于或等于它的数全部放在它的右边，对左右两个小数列重复上述步骤，直至各区间只有一个数。
	*/
	function quickSort (arr) {
		if (arr.length === 0) {
			return []
		}
		var left = []
		var right = []
		var pivot = arr[0]
		for (var i = 1; i < arr.length; i++) {
			if(arr[i] < pivot) {
				left.push(arr[i])
			} else {
				right.push(arr[i])
			}
			console.log('data', arr)
		}
		console.log('arr', arr)
		return quickSort(left).concat(pivot, quickSort(right))
	}
	console.log('快速排序quickSort', quickSort([1,5,3,4,2]))
</script>
</body>
</html>