<!DOCTYPE html>
<html>
<head>
	<title>继承</title>
</head>
<body>
<script type="text/javascript">
	//许多面向对象语言都支持两种继承方式：接口继承和实现继承。接口继承值继承方法签名，而实现继承则继承实际的方法。如前所述，由于函数没有签名，在ECMAScript中无法实现接口继承。ECMAScript只支持实现继承，而且其实实现继承主要依靠原型链来实现的。其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。
	//---------------------------------m
	//一、原型链
	//---------------------------------
	//1.构造函数、原型、实例三者关系
	//每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。这就形成链式关系也就是原型链。
	//每个构造函数都有一个原型，每个原型都有一个自带的属性constructor，这个属性指向当前构造函数；而实例是一个对象数据类型，且拥有一个__proto__属性，指向当前实例所属类的原型。
	//---------------------------------
	//2.原型链的查找机制
	//当访问一个对象某个属性（方法）时，会先从一个对象的私有属性（方法）中查找，如果找到则返回，否则通过__proto__向其原型查询，若无则通过原型的__proto__继续查找，一直找到基类Object为止。
	//附：原型的搜索机制：当以读取模式访问一个实例属性时，首先会在实例中搜索该属性。如果没有找到该属性，则会继续搜索实例的原型。
	//在通过原型链实现继承的情况下，搜索过程就得以沿着原型链继续向上。
	//---------------------------------
	//3.确定原型和实例的关系
	//可以通过两种方式来确定原型和实例的关系。第一种方式是使用instanceof操作符，只要用这个操作符来测试实例与原型链中出现过的构造函数，结果就会返回true。
	//第二种方式是使用isPropertyOf（）方法。同样，只要是原型链中出现过的原型，都可以说是该原型链所派生的实例的原型。
	//---------------------------------
	//注意：在通过原型链实现继承时，不能使用对象字面量创建原型方法，因为这样做就会重写原型链。
	//---------------------------------
	//原型继承的缺陷：1.子类的构造函数被改写为父类的构造函数  2.父类公有的和私有的均被称为子类公有的。 


</script>
</body>
</html>