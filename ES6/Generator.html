<!DOCTYPE html>
<html>
<head>
	<title></title>
</head>
<body>
<script type="text/javascript">
	// Generator函数
	// 概念：
	// 1.Es6提供的解决异步编程的方案之一
	// 2.Generator函数是一个状态机，内部封装了不同状态的数据
	// 3.用来生成遍历器对象
	// 4.可暂停函数（惰性求值），yield可暂停，next方法可启动。每次返回的时yield的表达式结果
	// 特点：
	// 1.function与函数名之间有一个星号
	// 2.内部用yield表达式来定义不同的状态
	// 例如：
	// function* generatorExample(){
	// 	let result = yield 'hello'; //状态值为hello
	// 	yield 'generator'; //状态值为generator
	// }
	// 3.generator函数返回的是指针对象，而不会执行函数内部逻辑

	function* myGenerator(){
		console.log("开始执行")
		let y1= yield 'hello';// yield默认返回undefined
		console.log(y1)
		console.log('暂停后，再次执行')
		yield 'generator'
		console.log('遍历完毕')
		return '改变返回的结果'
	}
	let mg = myGenerator(); //返回的是指针对象
	console.log(mg)// 遍历器对象
	console.log(mg.next()); // 函数执行，遇到yield暂停
	console.log(mg.next('gello')); //函数再次启动
	console.log(mg.next());

	//对象的symbol.iterator属性，指向遍历器对象
	let obj ={
		username: 'xzt',
		age: 29
	}
	obj[Symbol.iterator]=function* myTest(){
		yield 1
		yield 2
		yield 3
	}
	for(let i of obj) {
		console.log(i) // 1 2 3
	}

	// 案例练习
	// 需求：
	// 1.发送ajax请求获取新闻内容
	// 2.新闻内容获取成功后再次发送请求，获取对应的新闻评论功能
	// 3.新闻内容获取失败则不需要再次发送请求
	function getNews(url){
		$.get(url,function(data){
			console.log(data);
			let url2 = 'http://localhost:3000' +data.commentsUrl
			sx.next(url2
				)
		})
	}
	function* sendXml(){
		let url = yield getNews('http://localhost:3000/news?id=3');
		yield getNews(url)
	}
	// 获取遍历器对象
	let sx = sendXml();
	sx.next();
</script>
</body>
</html> 
